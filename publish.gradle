import java.security.MessageDigest
import org.gradle.internal.os.OperatingSystem

import java.nio.file.Files
import java.nio.file.Paths

apply plugin: 'maven-publish'

configurations {
    archives
}

publishing {
    repositories {
        maven {
            url "${System.getProperty('user.home')}/releases/maven/development"
        }
        maven {
            url "${System.getProperty('user.home')}/releases/maven/release"
        }
    }
}

def getPlatformPath(triplet) {
    if (triplet == "arm32-linux") {
        return "linux/arm32"
    } else if (triplet == "arm64-linux") {
        return "linux/arm64"
    } else if (triplet == "x64-linux") {
        return "linux/x86-64"
    } else if (triplet == "x64-osx") {
        return "osx/x86-64"
    } else if (triplet == "arm64-osx") {
        return "osx/arm64"
    } else if (triplet == "x64-windows") {
        return "windows/x86-64"
    } else if (triplet == "arm64-windows") {
        return "windows/arm64"
    } else {
        return ""
    }
}

ext.triplet = platform
ext.platformPath = getPlatformPath(ext.triplet)
ext.platformClassifier = ext.platformPath.replaceFirst('/', '')

ext.repo = "thirdparty-gtsam"

def triplet = platform

def pubVersion = "2.2-1"

def outputsFolder = file("$project.buildDir/outputs")

def baseArtifactId = 'gtsam'
def artifactGroupId = 'edu.wpi.first.thirdparty.frc2025.gtsam'
def zipBaseName = '_GROUP_edu_wpi_first_thirdparty_frc2025_gtsam_ID_gtsam-cpp_CLS'

def versionFile = file("$outputsFolder/version.txt")
def licenseFile = file("LICENSE.md")

def outputClassifierStatic = project.ext.platformClassifier + 'static'
def outputClassifierDebugStatic = project.ext.platformClassifier + 'debug/static'
System.out.println(triplet)


task copyAllOutputs(type: Copy) {
    destinationDir = outputsFolder
}

ext.addTaskToCopyAllOutputs = { task ->
    copyAllOutputs.dependsOn task
    copyAllOutputs.inputs.file task.archiveFile
    copyAllOutputs.from task.archiveFile
}

task outputVersions() {
    description = 'Prints the versions of this to a file for use by the downstream packaging project'
    group = 'Build'
    outputs.files(versionFile)

    doFirst {
        buildDir.mkdir()
        outputsFolder.mkdir()
    }

    doLast {
        versionFile.write pubVersion
    }
}

task cmakeRelease() {
    doFirst {
        exec {
            workingDir rootDir
            def args
            if (platform.contains("windows")) {
                args = [
                    "cmake",
                    "-B build",
                    "-G Ninja",
                    "-DCMAKE_BUILD_TYPE=Release",
                ]
            } else {
                args = [
                    "cmake",
                    "-B build",
                    "-G Ninja",
                    "-DCMAKE_C_COMPILER_LAUNCHER=sccache",
                    "-DCMAKE_CXX_COMPILER_LAUNCHER=sccache ",
                    "-DCMAKE_BUILD_TYPE=Release",
                ]
            }
            commandLine args
        }
        exec {
            workingDir rootDir
            def args = [
                "cmake",
                "--build",
                "build",
                "--parallel",
                "6"
            ]
            commandLine args
        }
    }
}
task cppLibsZipStatic(type: Zip) {
    dependsOn cmakeRelease

    destinationDirectory = outputsFolder
    archiveClassifier = outputClassifierStatic
    archiveBaseName = zipBaseName
    duplicatesStrategy = 'exclude'

    from(licenseFile) {
        into '/'
    }
    def resolvedDir = Paths.get(projectDir.canonicalPath).resolve("build/_deps/gtsam-build")
    from(resolvedDir.toFile()) {
        into project.platformPath + '/static'
        exclude '**/pkgconfig'
        include '**/*.a'
        include '**/*.lib'
        include '**/*.pdb'
    }
}

task cmakeDebug() {
    doFirst {
        exec {
            workingDir rootDir
            def args
            if (platform.contains("windows")) {
                args = [
                    "cmake",
                    "-B buildDebug",
                    "-G Ninja",
                    "-DCMAKE_BUILD_TYPE=Debug",
                ]
            } else {
                args = [
                    "cmake",
                    "-B buildDebug",
                    "-G Ninja",
                    "-DCMAKE_C_COMPILER_LAUNCHER=sccache",
                    "-DCMAKE_CXX_COMPILER_LAUNCHER=sccache ",
                    "-DCMAKE_BUILD_TYPE=Debug",
                ]
            }
            commandLine args
        }
        exec {
            workingDir rootDir
            def args = [
                "cmake",
                "--build",
                "buildDebug",
                "--parallel",
                "6"
            ]
            commandLine args
        }
    }
}

task cppLibsZipStaticDebug(type: Zip) {
    dependsOn cmakeDebug

    destinationDirectory = outputsFolder
    archiveClassifier = outputClassifierStatic + 'debug'
    archiveBaseName = zipBaseName + 'debug'
    duplicatesStrategy = 'exclude'

    from(licenseFile) {
        into '/'
    }
    def resolvedDir = Paths.get(projectDir.canonicalPath).resolve("buildDebug/_deps/gtsam-build")
    from(resolvedDir.toFile()) {
        into project.platformPath + '/static'
        exclude '**/pkgconfig'
        include '**/*.a'
        include '**/*.lib'
        include '**/*.pdb'
    }
}

task copyHeaders() {
    dependsOn cmakeDebug
    doFirst {
        exec {
            workingDir rootDir
            def args = [
                "sh",
                "-c",
                "./copy-headers.sh"
            ]
            commandLine args
        }
    }
}

task cppHeadersZip(type: Zip) {
    dependsOn outputVersions
    dependsOn copyHeaders
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    archiveClassifier = "headers"

    from(licenseFile) {
        into '/'
    }
    def resolvedDir = Paths.get(projectDir.canonicalPath).resolve("gradleDir/include")
    from(resolvedDir.toFile()) {
        into '/include'
        include '**/*.hpp', '**/*.h'
    }

    includeEmptyDirs = false
}

if (!project.hasProperty('skipRelease')) {
    addTaskToCopyAllOutputs(cppLibsZipStatic)
}

if (!project.hasProperty('skipDebug')) {
    addTaskToCopyAllOutputs(cppLibsZipStaticDebug)
}

def isDev = true

if (project.hasProperty('release')) {
    isDev = false
}

def photonMavenURL = 'https://maven.photonvision.org/' + (isDev ? 'snapshots' : 'releases');

if (project.hasProperty("thirdparty")) {
    model {
        publishing {
            publications {
                cpp(MavenPublication) {
                    artifact cppHeadersZip
                    artifact cppLibsZipStatic
                    artifact cppLibsZipStaticDebug

                    artifactId = "${baseArtifactId}-cpp"
                    groupId artifactGroupId
                    version pubVersion
                }
            }
            repositories {
                maven {
                        url(photonMavenURL)
                        credentials {
                            username 'ghactions'
                            password System.getenv("ARTIFACTORY_API_KEY")
                    }
                }
            }
        }
    }
} else {
    model {
        publishing {
            publications {
                cpp(MavenPublication) {
                    artifact cppHeadersZip
                    artifact cppLibsZipStatic
                    artifact cppLibsZipStaticDebug

                    artifactId = "${baseArtifactId}-cpp"
                    groupId artifactGroupId
                    version pubVersion
                }
            }
            repositories {
                maven {
                    url "${System.getProperty('user.home')}/releases/maven/${project.repo}"
                }
            }
        }
    }
}
